from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.orm import Session
from app.crud.blog import create_blog_post, get_blog_post, delete_blog_post
from app.schemas.blog import BlogPostCreate, BlogPostUpdate
from app.db.session import get_db
from app.core.security import get_current_user
from app.models.user import User
from app.tasks.ai_agent import generate_blog_post  # async AI generation function
import traceback
from app.models.blog import BlogPost
from app.background_tasks.blog_task import generate_blog_content  # Background task function

router = APIRouter()



#--------------------------------------------------------------- Create Blog -----------------------------------------------------------------------------------------

@router.post("/blogs", status_code=201)
async def create_blog(
    blog: BlogPostCreate,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Create a new blog post with status 'pending' and schedule AI content generation in the background.
    """
    try:
        # Create a blog post with empty content and a pending status.
        pending_data = {
            "title": blog.title,
            "content": "",         # Content to be generated by the AI agent in the background.
            "status": "pending"    # Status tracking field.
        }
        # Create the blog post in the database.
        db_blog = create_blog_post(db, BlogPostCreate(**pending_data), current_user.id)
        
        # Schedule the background task to generate the blog content.
        # We pass the input content (blog.content) as parameter if needed by the AI agent.
        background_tasks.add_task(generate_blog_content, db, db_blog.id, blog.content)
        
        # return db_blog
        return{"message": "Blog creation is being processed.", "blog": db_blog}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    

#--------------------------------------------------------------- Read All Blogs -----------------------------------------------------------------------------------------

@router.get("/blogs")
def read_all_blogs(db: Session = Depends(get_db)):
    """
    Retrieve all blog posts.
    """
    blogs = db.query(BlogPost).all()
    if not blogs:
        raise HTTPException(status_code=404, detail="No blog posts found")
    
    # Return the list directly
    return blogs


#--------------------------------------------------------------- Read a Single Blog -----------------------------------------------------------------------------------------


@router.get("/blogs/{id}")
def read_blog(id: int, db: Session = Depends(get_db)):
    db_blog = get_blog_post(db, id)
    if db_blog is None:
        raise HTTPException(status_code=404, detail="Blog post not found")
    return db_blog

#--------------------------------------------------------------- Update a Blog -----------------------------------------------------------------------------------------


@router.put("/blogs/{id}", status_code=202)
async def update_blog(
    id: int,
    blog_data: BlogPostUpdate,
    background_tasks: BackgroundTasks,  # Inject BackgroundTasks directly
    db: Session = Depends(get_db)
):
    """
    The blog post is first updated with the provided data and marked as "pending", and then
    a background task generates the final AI content.
    """
    try:
        blog = db.query(BlogPost).filter(BlogPost.id == id).first()
        if not blog:
            raise HTTPException(status_code=404, detail="Blog post not found.")
        
        # Update the blog with the new data from the request
        blog.title = blog_data.title
        blog.content = blog_data.content
        blog.status = "pending"  # Mark the blog for update processing
        db.commit()
        db.refresh(blog)
        
        # Schedule the background task to generate updated content.
        # We pass the current input (blog_data.content) as a basis for the AI agent.
        background_tasks.add_task(generate_blog_content, db, blog.id, blog_data.content)
        
        # Return a response indicating that the update request is accepted for processing.
        return {"message": "Blog update is being processed.", "blog": blog}
    except Exception as e:
        import traceback
        print(f"Error updating blog: {str(e)}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Failed to update blog post: {str(e)}")


#--------------------------------------------------------------- Delete Blog -----------------------------------------------------------------------------------------

@router.delete("/blogs/{id}")
def delete_blog(id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    db_blog = delete_blog_post(db, id, current_user.id)
    if db_blog is None:
        raise HTTPException(status_code=404, detail="Blog post not found")
    return {"message": "Blog post deleted successfully"}